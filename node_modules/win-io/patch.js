// Servo code (tested with HITEC HS645-MG) is based on:
// https://github.com/adafruit/Adafruit-PWM-Servo-Driver-Library
// The configuration is based on the Raspberry Pi attached to 2 servo hats:
// SERVO_HAT_TOP_I2C_ADDRESS: Pins 0-14
// SERVO_HAT_BOTTOM_I2C_ADDRESS: Pins 13-15



// Add the following code right after the requires in lib/win-io.js
// ********************************************************************************
var sleep = require("sleep");

var I2C_CONTROLLER_NAME = 'I2C1'; // Specific to RPi2 with Windows 10 IoT Core

var i2c = require('i2c-bus'),
  i2c1 = i2c.openSync(I2C_CONTROLLER_NAME);

var log = console.info

var SERVO_HAT_BOTTOM_I2C_ADDRESS = 0x41; //address of the bottom servo control hat 
var SERVO_HAT_TOP_I2C_ADDRESS = 0x42; // address of the top servo control hat 


var PCA9685_MODE1 = 0x0;
var PCA9685_PRESCALE = 0xFE;
  
// Depending on your servo make, the pulse width min and max may vary, you 
// want these to be as small/large as possible without hitting the hard stop
// for max range. You'll have to tweak them as necessary to match the servos you
// have!
var SERVOMIN = 150; // this is the 'minimum' pulse length count (out of 4096)
var SERVOMAX = 600; // this is the 'maximum' pulse length count (out of 4096)


var LED0_ON_L = 0x6;
var LED0_ON_H = 0x7;
var LED0_OFF_L = 0x8;
var LED0_OFF_H = 0x9;

function begin(addr) {
  i2c1.i2cWriteSync(addr, 2, new Buffer([PCA9685_MODE1, 0x0]));
}

function setPWMFreq(addr, freq) {
  const buffer = new Buffer(1);

  freq *= 0.9;  // Correct for overshoot in the frequency setting (see issue #11).
  var prescaleval = 25000000;
  prescaleval /= 4096;
  prescaleval /= freq;
  prescaleval -= 1;

  var prescale = Math.floor(prescaleval + 0.5);
  
  i2c1.readI2cBlockSync(addr, PCA9685_MODE1, 1, buffer);
  var oldmode = buffer[0];
  log('oldmode: ', oldmode);
  var newmode = (oldmode & 0x7F) | 0x10; // sleep
  log('newmode: ', newmode);
  i2c1.i2cWriteSync(addr, 2, new Buffer([PCA9685_MODE1, newmode])); // go to sleep
  i2c1.i2cWriteSync(addr, 2, new Buffer([PCA9685_PRESCALE, prescale])); // set the prescaler
  i2c1.i2cWriteSync(addr, 2, new Buffer([PCA9685_MODE1, oldmode]));
  sleep.usleep(5);
  i2c1.i2cWriteSync(addr, 2, new Buffer([PCA9685_MODE1, oldmode])); //  This sets the MODE1 register to turn on auto increment.
                                              // This is why the beginTransmission below was not working.
}

// you can use this function if you'd like to set the pulse length in seconds
// e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. its not precise!
function setServoPulse(n, pulse) {
  var pulselength;
  var pin = n;

  pulselength = 1000000;   // 1,000,000 us per second
  pulselength /= 60;   // 60 Hz
  log(pulselength, " us per period"); 
  pulselength /= 4096;  // 12 bits of resolution
  log(pulselength, " us per bit"); 
  pulse *= 1000;
  pulse /= pulselength;
  log("pin: ", n, "pulse: ", pulse); 
  //setPWM(n, 0, pulse);

  var addr = SERVO_HAT_TOP_I2C_ADDRESS;
     
  switch(pin)
  {
    case 16:
      pin = 13;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
    case 17:
      pin = 14;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
    case 18:
      pin = 15;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
  }
  
  var on = 0;
  var off = SERVOMIN + (pulse * 2.5);

  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_ON_L + (4 * pin)), (on & 0xFF)]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_ON_H + (4 * pin)), (on >> 8)]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_OFF_L + (4 * pin)), off]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_OFF_H + (4 * pin)), (off >> 8)]));
}
// ********************************************************************************
  
  
// Add the following code in the BoardIO function.
// ********************************************************************************
begin(SERVO_HAT_TOP_I2C_ADDRESS);
begin(SERVO_HAT_BOTTOM_I2C_ADDRESS);
setPWMFreq(SERVO_HAT_TOP_I2C_ADDRESS, 60);
setPWMFreq(SERVO_HAT_BOTTOM_I2C_ADDRESS, 60);
var i2c_pins = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18];
for (let i = 0; i < i2c_pins.length; i++) {
  setServoPulse(i2c_pins[i], 0.002);
}
// ********************************************************************************


// Replace servoWrite with the function below
// ********************************************************************************
BoardIO.prototype.servoWrite = function (pin, value) {
  var addr = SERVO_HAT_TOP_I2C_ADDRESS;
     
  switch(pin)
  {
    case 16:
      pin = 13;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
    case 17:
      pin = 14;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
    case 18:
      pin = 15;
      addr = SERVO_HAT_BOTTOM_I2C_ADDRESS;
      break;
  }
  
  var on = 0;
  var off = SERVOMIN + (value * 2.5);

  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_ON_L + (4 * pin)), (on & 0xFF)]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_ON_H + (4 * pin)), (on >> 8)]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_OFF_L + (4 * pin)), off]));
  i2c1.i2cWriteSync(addr, 2, new Buffer([(LED0_OFF_H + (4 * pin)), (off >> 8)]));
}
// ********************************************************************************
